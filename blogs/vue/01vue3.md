---
title: 01 Vue3.0 
date: 2021-03-01
categories: 
 - Vue
tags:
 - Vue3
---

## 一、Vue 3.0 相关技术栈

| **相关库名称**      | 在线地址                                                     |
| ------------------- | ------------------------------------------------------------ |
| Vue 3.0 中文文档    | [在线地址](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2F) [国内加速版](https://link.juejin.cn/?target=https%3A%2F%2Fvue3js.cn%2Fdocs%2Fzh%2F) |
| Composition-API手册 | [在线地址](https://link.juejin.cn/?target=https%3A%2F%2Fvue3js.cn%2Fvue-composition-api%2F) |
| Vue 3.0 源码学习    | [在线地址](https://link.juejin.cn/?target=https%3A%2F%2Fvue3js.cn%2Fstart%2F) |
| Vue-Router 官方文档 | [在线地址](https://link.juejin.cn/?target=https%3A%2F%2Fnext.router.vuejs.org%2F) |
| Vuex 4.0            | [Github](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvuex%2Ftree%2F4.0) |
| vue-devtools        | [Github](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-devtools%2Freleases)(Vue3.0 需要使用最新版本) |
| Vite 源码学习       | [线上地址](https://link.juejin.cn/?target=https%3A%2F%2Fvite-design.surge.sh%2Fguide%2F) |
| Vite 2.0 中文文档   | [线上地址](https://link.juejin.cn/?target=https%3A%2F%2Fcn.vitejs.dev%2F) |

## 二、Vue3

### 1.Vue3简介

[官方文档](https://v3.cn.vuejs.org/guide/installation.html#vite)

- 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）
- 耗时2年多、[2600+次提交](https://github.com/vuejs/vue-next/graphs/commit-activity)、[30+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)、[99位贡献者](https://github.com/vuejs/vue-next/graphs/contributors) 
- [github上的tags地址](https://github.com/vuejs/vue-next/releases/tag/v3.0.0)

### 2.Vue3带来了什么

- 性能的提升

  - 打包大小减少41%

  - 初次渲染快55%, 更新渲染快133%

  - 内存减少54%

- 源码的升级

  - 使用Proxy代替defineProperty实现响应式

  - 重写虚拟DOM的实现和Tree-Shaking

- 拥抱TypeScript
  - Vue3可以更好的支持TypeScript

### 3.创建Vue3.0工程

- 使用 vue-cli 创建
- [官方文档](https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create)

```bash
## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
```

- [vite官网](https://vitejs.cn)

  - `vite`是尤雨溪团队开发的新一代的**前端构建工具**，意图取代`webpack`

  - 优势如下：
    - 开发环境中，无需打包操作，可快速的冷启动。
    - 轻量快速的热重载（HMR）。
    - 真正的按需编译，不再等待整个应用编译完成。

  - 传统构建 与 vite构建对比：
    -  webpack是一开始是入口文件，然后分析路由，然后模块，最后进行打包，然后告诉你，服务器准备好了（默认8080）
       <img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210122324505.png" alt="image-20221012232346738" style="zoom:50%;" />
    -  而vite一开始是先告诉你服务器准备完成，然后等你发送HTTP请求，然后是入口文件，`Dynamic import`（动态导入）`code split point`（代码分割）
       <img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210122324210.png" alt="image-20221012232436633" style="zoom:50%;" />

```bash
## 创建工程
npm init vite-app <project-name>
## 进入工程目录
cd <project-name>
## 安装依赖
npm install
## 运行
npm run dev
```

### 4.分析工程结构

创建完成vue3项目后，点击main.js，会发现写法发生了改变：

<img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210122336393.png" alt="image-20221012233558618" style="zoom: 52%;" />

<img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210122336431.png" alt="image-20221012233159242" style="zoom:50%;" />

## 三、Composition API

[官方文档](https://v3.cn.vuejs.org/guide/composition-api-introduction.html)

### 1.setup

- 理解：Vue3.0中一个新的配置项，值为一个函数。

- setup 是组件内使用 `Composition API`的入口。

- 组件中所用到的：数据、方法等等，均要配置在setup中。

- setup函数的两种返回值：

  - 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）

  - <span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span>

    ```js
    import { h, ref } from 'vue'
    
    export default {
      setup() {
        const count = ref(0)
        return () => h('div', count.value)
      }
    }
    ```

- 尽量不要与Vue2.x配置混用。vue2中可以读取到vue3里的配置但是vue3里面不能读取到vue2的配置。

  - Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。

  - 但在setup中不能访问到Vue2.x配置（data、methos、computed...）。

  - 如果有重名, setup优先。

- setup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）。

- setup执行的时机：在beforeCreate之前执行一次，this是undefined。

- setup的参数

  - props：值为对象，包含：组件外部传递过来，且**组件内部声明接收了的属性**。

  - context：上下文对象

    - `attrs`: 值为对象，包含：组件外部传递过来，但**没有在props配置中声明的属性**， 相当于 `this.$attrs`。

    - `slots`: 收到的插槽内容,，相当于 ```this.$slots```。

    - `emit`：触发自定义事件， 相当于 ```this.$emit```。

    - `expose `：`expose` 函数用于显式地限制该组件暴露出的属性，当父组件通过[模板引用](https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component)访问该组件的实例时，将仅能访问 `expose` 函数暴露出的内容：


       ```js
export default {
  setup(props, { expose }) {
    // 让组件实例处于 “关闭状态”
    // 即不向父组件暴露任何东西
    expose()

    const publicCount = ref(0)
    const privateCount = ref(0)
    // 有选择地暴露局部状态
    expose({ count: publicCount })
  }
}
       ```

- `props` 对象是响应式的，**不能使用 ES6 解构**，解构出的变量将会丢失响应性。推荐通过 `props.xxx` 的形式来使用其中的 props。
- content是一个普通的对象，`context`中就提供了中三个属性：

  - `attrs`、`slot` 和`emit`
  - 分别对应 Vue2.x 中的 `$attr`属性、`slot`插槽 和`$emit`发射事件。

```js
export default defineComponent ({
    setup(props, context) {
        const { name } = props //错误代码
        console.log(name)
        // 将 `props` 转为一个其中全是 ref 的对象，然后解构
        const { title } = toRefs(props)
        // `title` 是一个追踪着 `props.title` 的 ref
        console.log(title.value)

        // 或者，将 `props` 的单个属性转为一个 ref
        const title = toRef(props, 'title')
    },
})
//上下文对象是非响应式的，可以安全地解构
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
```

`attrs` 和 `slots` 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当**避免解构它们**，并始终通过 `attrs.x` 或 `slots.x` 的形式使用其中的属性。此外还需注意，和 `props` 不同，`attrs` 和 `slots` 的属性都**不是**响应式的。如果你想要基于 `attrs` 或 `slots` 的改变来执行副作用，那么你应该在 `onBeforeUpdate` 生命周期钩子中编写相关逻辑。

###  2.ref()函数

接受一个内部值，返回一个**响应式的**、**可更改的 ref 对象**，此对象只有一个指向其内部值的属性 `.value`。

- 作用: 定义一个响应式的数据

- 语法: `const xxx = ref(initValue)`

  - 创建一个包含响应式数据的引用对象（`reference`对象，简称`ref`对象）。
  - JS中操作数据： `xxx.value`
  - 模板中读取数据: 不需要`.value`

  ```html
  <div>{{xxx}}</div>
  <script>
  const count = ref(0)
  console.log(count.value) // 0
  
  count.value++
  console.log(count.value) // 1
  </script>
  ```

- 备注：

  - 接收的数据可以是：基本类型、也可以是对象类型。
  - 基本类型的数据：响应式依然是靠`Object.defineProperty()`的`get`与`set`完成的。
  - 对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— `reactive`函数。

![image-20221004164050937](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210041640183.png)

### 3.reactive函数

返回一个对象的响应式代理。

- 作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（不能代理基本类型，要用`ref`函数）。把对象类型数据变成Vue可以监测到的响应式数据。
- 语法：```const 代理对象= reactive(源对象)```接收一个对象（或数组），返回一个代理对象Proxy（**Proxy的实例对象，简称proxy对象）**。通过代理对象 操作 **源对象** 内部数据。
- reactive定义的响应式数据是**深层次**的。
- 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。

### 4.reactive对比ref

-  从定义数据角度对比：
   -  ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。
   -  reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。
   -  备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过```reactive```转为<strong style="color:#DD5145">代理对象</strong>。
-  从原理角度对比：
   -  ref通过``Object.defineProperty()``的```get```与```set```来实现响应式（数据劫持）。
   -  reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作源对象内部的数据。
-  从使用角度对比：
   -  ref定义的数据：操作数据需要```.value```，读取数据时**模板**中直接读取不需要```.value```。
   -  reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong>```.value```。


### 5.计算属性与监视

#### 5.1 computed函数

- 与Vue2.x中computed配置功能一致

- 写法

  ```js
  import {computed} from 'vue'
  
  setup(){
      ...
    //计算属性——简写 computed是一个函数
      let fullName = computed(()=>{
          return person.firstName + '-' + person.lastName
      })
      //计算属性——完整 computed是一个对象
      let fullName = computed({
          get(){
              return person.firstName + '-' + person.lastName
          },
          set(value){
              const nameArr = value.split('-')
              person.firstName = nameArr[0]
              person.lastName = nameArr[1]
          }
      })
  }
  ```

#### 5.2 watch函数

watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是惰性的，也就是说仅在侦听的源数据变更时才执行回调。

- 与Vue2.x中watch配置功能一致

- 两个小“坑”：

  - 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。
  - 监视reactive定义的响应式数据中某个属性时：deep配置有效。

![](https://wf-cloud-img.oss-cn-hangzhou.aliyuncs.com/image/202210041647255.png)

```js
//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=>{
  console.log('sum变化了',newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=>{
  console.log('sum或msg变化了',newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
      若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
      若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
      如果person是ref定义的，则需要监测person.value或者开启深度监视
*/
watch(person,(newValue,oldValue)=>{
  console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=>person.job,(newValue,oldValue)=>{
  console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{
  console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=>person.job,(newValue,oldValue)=>{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性（属性job也是对象），所以deep配置有效
```

#### 5.3 watchEffect函数

立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行.

- watch的套路是：既要指明监视的属性，也要指明监视的回调。

- watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。

- watchEffect有点像computed：

  - 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。
  - 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。

  ```js
  //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
  watchEffect(()=>{
      const x1 = sum.value //sum是ref所定义的
      const x2 = person.age
      console.log('watchEffect配置的回调执行了')
  })
  ```

### 6.生命周期

- Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
  - ```beforeDestroy```改名为 ```beforeUnmount```
  - ```destroyed```改名为 ```unmounted```
- Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
  - `beforeCreate`===>`setup()`
  - `created`=======>`setup()`
  - `beforeMount` ===>`onBeforeMount`
  - `mounted`=======>`onMounted`
  - `beforeUpdate`===>`onBeforeUpdate`
  - `updated` =======>`onUpdated`
  - `beforeUnmount` ==>`onBeforeUnmount`
  - `unmounted` =====>`onUnmounted`

<img src="https://wf-cloud-img.oss-cn-hangzhou.aliyuncs.com/image/202210041721762.png" alt="image-20221004165153084" style="zoom: 25%;" />

### 7.自定义hook函数

- 什么是`hook`？—— 本质是一个函数，**把setup函数中使用的Composition API进行了封装**。
- 类似于vue2.x中的`mixin`。
- 自定义hook的优势: 复用代码，让`setup`中的逻辑更清楚易懂。

<img src="https://wf-cloud-img.oss-cn-hangzhou.aliyuncs.com/image/202210041653012.png" alt="image-20221004165333898" style="zoom:80%;" />

<img src="https://wf-cloud-img.oss-cn-hangzhou.aliyuncs.com/image/202210041835517.png" alt="image-20221004165412639" style="zoom:80%;" />

### 8.toRef

上面说到setup 中**不可以使用 ES6 解构**，解构会消除响应式。解决办法就是**使用`toRef、toRefs`**。 

- 作用：创建一个 `ref `对象，其`value`值指向另一个对象中的某个属性。
- `const name = toRef(person,'name')` **创建一个ref对象name，其value值指向person中的name属性**。
- 应用：要将响应式对象中的某个属性单独提供给外部使用时。
- `toRef` 与`toRef`功能一致，但可以批量创建多个 ref 对象，语法：`toRefs(person)`。

**ref和toRef区别：**

- 利用`ref函数`将某个对象中的属性变成响应式数据，修改响应式数据**不会影响到原始数据**。
- 使用`toRef`将某个**对象中的属性**变成响应式数据，修改响应式数据是**会影响到原始数据的**。
- `ref`的本质是拷贝，与原始数据没有引用关系。
- `toRef`的本质是引用，与原始数据有关联。

```js
template>
  <div class="homePage">
    <p>第 {{ year }} 年</p>
    <p>姓名： {{ nickname }}</p>
    <p>年龄： {{ age }}</p>
  </div>
</template>

<script>
import { defineComponent, reactive, ref, toRefs } from "vue";
export default defineComponent({
  setup() {
    const year = ref(0);
    const user = reactive(
        { 
            nickname: "ss", 
            age: 26, 
            gender: "女" ,
            job:{
                j1{
                salary:20
            }
            }
        });
    setInterval(() => {
      year.value++;
      user.age++;
    }, 1000);
    return {
      year,
      nickname:toRef(user,'nickname'),
      age:toRef(user,'age'),
      gender:toRef(user,'gender')
      salary:toRef(user.job.j1,'salary')
      // 解构赋值 使用reRefs
      //...toRefs(user),
    };
  },
});
</script>
import {ref} from 'vue';
export default {
  name:'App'
  setup(){
    let obj = {name : 'alice', age : 12};

    function change(){
      newObj.value = 'Tom';
      console.log(obj,newObj)
    }
    return {
        newObj:ref(obj.name),
        change
    }
  }
}
```

上述代码，当`change`执行的时候，响应式数据发生改变，而原始数据`obj`并不会改变。

原因在于：`ref`的本质是**拷贝**，与原始数据没有引用关系。

需要注意`ref(obj.name)`相当于`ref('alice')`

## 四、其它 Composition API

### 1.shallowReactive 与 shallowRef

- `shallowReactive`：只处理对象最外层属性的响应式（浅响应式）。
- `shallowRef`：只处理基本数据类型的响应式, 不进行对象的响应式处理。

- 什么时候使用：
  -  如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> `shallowReactive`。
  -  如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> `shallowRef`。

### 2.readonly 与 shallowReadonly

- `readonly`: 让一个响应式数据变为只读的（深只读）。
- `shallowReadonly`：让一个响应式数据变为只读的（浅只读）。
- 应用场景: 不希望数据被修改时。

### 3.toRaw 与 markRaw

- `toRaw`：
  - 作用：将一个由```reactive```生成的**响应式对象**转为**普通对象**。
  - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。

- `markRaw`：
  - 作用：标记一个对象，使其永远不会再成为响应式对象。

  - 应用场景:

    - 有些值不应被设置为响应式的，例如复杂的第三方类库等。

    - 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。

### 4.customRef

- 作用：创建一个自定义的 `ref`，并对其依赖项跟踪和更新触发进行显式控制。

- 实现防抖效果：

  ```vue
  <template>
    <input type="text" v-model="keyword">
    <h3>{{keyword}}</h3>
  </template>
  
  <script>
    import {ref,customRef} from 'vue'
    export default {
      name:'Demo',
      setup(){
        // let keyword = ref('hello') //使用Vue准备好的内置ref
        //自定义一个myRef
        function myRef(value,delay){
          let timer
          //通过customRef去实现自定义
          return customRef((track,trigger)=>{
            return{
              get(){
                track() //告诉Vue这个value值是需要被“追踪”的
                return value
              },
              set(newValue){
                clearTimeout(timer)
                timer = setTimeout(()=>{
                  value = newValue
                  trigger() //告诉Vue去更新界面
                },delay)
              }
            }
          })
        }
        let keyword = myRef('hello',500) //使用程序员自定义的ref
        return {
          keyword
        }
      }
    }
  </script>
  ```

### 5.provide 与 inject

- 作用：实现**祖与后代组件**间通信

- 套路：父组件有一个 `provide` 选项来提供数据，后代组件有一个 `inject` 选项来开始使用这些数据

- 具体写法：

  1. 祖组件中：

     ```js
     setup(){
      ......
         let car = reactive({name:'奔驰',price:'40万'})
         provide('car',car)
         ......
     }
     ```

  2. 后代组件中：

     ```js
     setup(props,context){
      ......
         const car = inject('car')
         return {car}
      ......
     }
     ```

### 6.响应式数据的判断

- `isRef`: 检查一个值是否为一个 ref 对象
- `isReactive`: 检查一个对象是否是由 `reactive` 创建的响应式代理
- `isReadonly`: 检查一个对象是否是由 `readonly` 创建的只读代理
- `isProxy`: 检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理

## 五、Composition API 的优势

### 1.Options API 存在的问题

使用传统`OptionsAPI`（配置API）中，新增或者修改一个需求，就需要分别在`data`，`methods`，`computed`里修改 。

<img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210041141702.gif" style="zoom:80%;width:454px;" />
<img src="https://wf-cloud-img.oss-cn-hangzhou.aliyuncs.com/image/202210041142080.gif" style="zoom:50%;width:360px;" />


### 2.Composition API 的优势

我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。

 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:200px"/>
 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:200px"/>


## 六、Vue3.0的响应式

- 实现原理: 

  - 通过`Proxy`（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。

  - 通过`Reflect`（反射）:  对源对象的属性进行操作。

  - MDN文档中描述的`Proxy`与`Reflect`：

    - Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy

    - Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect

      ```js
      new Proxy(data, {
        // 拦截读取属性值
          get (target, prop) {
            return Reflect.get(target, prop)
          },
          // 拦截设置属性值或添加新属性
          set (target, prop, value) {
            return Reflect.set(target, prop, value)
          },
          // 拦截删除属性
          deleteProperty (target, prop) {
            return Reflect.deleteProperty(target, prop)
          }
      })
      
      proxy.name = 'tom'   
      ```

## 七、新的组件

### 1.Fragment

- 在Vue2中: 组件必须有一个根标签
- 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中
- 好处: 减少标签层级, 减小内存占用

### 2.Teleport

- 什么是Teleport？—— `Teleport` 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。

  ```vue
  <teleport to="移动位置">
    <div v-if="isShow" class="mask">
      <div class="dialog">
        <h3>我是一个弹窗</h3>
        <button @click="isShow = false">关闭弹窗</button>
      </div>
    </div>
  </teleport>
  ```

### 3.Suspense

- 等待异步组件时渲染一些额外内容，让应用有更好的用户体验

- 使用步骤：

  - 异步引入组件

    ```js
    import {defineAsyncComponent} from 'vue'
    const Child = defineAsyncComponent(()=>import('./components/Child.vue'))
    ```

  - 使用```Suspense```包裹组件，并配置好```default``` 与 ```fallback```

    ```js
    <template>
      <div class="app">
        <h3>我是App组件</h3>
        <Suspense>
          <template v-slot:default>
            <Child/>
          </template>
          <template v-slot:fallback>
            <h3>加载中.....</h3>
          </template>
        </Suspense>
      </div>
    </template>
    ```

## 八、其他改变

### 1.全局API的转移

- Vue 2.x 有许多全局 API 和配置。

  - 例如：注册全局组件、注册全局指令等。

    ```js
    //注册全局组件
    Vue.component('MyButton', {
      data: () => ({
        count: 0
      }),
      template: '<button @click="count++">Clicked {{ count }} times.</button>'
    })
    
    //注册全局指令
    Vue.directive('focus', {
      inserted: el => el.focus()
    }
    ```

- Vue3.0中对这些API做出了调整：

  - 将全局的API，即：`Vue.xxx`调整到应用实例（`app`）上

    | 2.x 全局 API（`Vue`）    | 3.x 实例 API (`app`)                        |
    | ------------------------ | ------------------------------------------- |
    | Vue.config.xxxx          | app.config.xxxx                             |
    | Vue.config.productionTip | <strong style="color:#DD5145">移除</strong> |
    | Vue.component            | app.component                               |
    | Vue.directive            | app.directive                               |
    | Vue.mixin                | app.mixin                                   |
    | Vue.use                  | app.use                                     |
    | Vue.prototype            | app.config.globalProperties                 |

### 2.其他改变

- data选项应始终被声明为一个函数。

- 过度类名的更改：

  - Vue2.x写法

    ```css
    .v-enter,
    .v-leave-to {
      opacity: 0;
    }
    .v-leave,
    .v-enter-to {
      opacity: 1;
    }
    ```

  - Vue3.x写法

    ```css
    .v-enter-from,
    .v-leave-to {
      opacity: 0;
    }
    
    .v-leave-from,
    .v-enter-to {
      opacity: 1;
    }
    ```

- <strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持```config.keyCodes```

- <strong style="color:#DD5145">移除</strong>```v-on.native```修饰符

  - 父组件中绑定事件

    ```vue
    <my-component
      v-on:close="handleComponentEvent"
      v-on:click="handleNativeClickEvent"
    />
    ```

  - 子组件中声明自定义事件

    ```vue
    <script>
      export default {
        emits: ['close']
      }
    </script>
    ```

- <strong style="color:#DD5145">移除</strong>过滤器（filter）

  > 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。