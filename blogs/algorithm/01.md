---
title: 01 线性结构
date: 2022-8-29
categories: 
 - 算法
tags:
 - 数组
 - 栈
 - 队列
 - 链表
---
## 一、数组

## 二、栈（Stack）

栈（stack）是一种运算**受限**的线性结构：

- **先进后出，后进先出**`LIFO：(last in first out)`。
- 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
- 向一个栈插入新元素又称作**进栈**、**入栈**或**压栈**，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
- 从一个栈删除元素又称作**出栈**或**退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

![image-20200226131817102](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210070943635.png)

**程序中的栈结构：**

- 栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）。

- **函数调用栈**：A（B（C（D（））））：
  - 即A函数中调用B，B调用C，C调用D；
  - 在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。
  - 所以当前栈的顺序为：A->B->C->D（栈顶）；
  - 函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D->C->B->A;

- **递归**：为什么没有停止条件的递归会造成栈溢出？
  - 比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈）
  - 不停地把相同的函数A压入栈，最后造成**栈溢出**（Stack Overfloat）

```txt
练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？

- A：5 4 3 6 1 2 （√）
- B：4 5 3 2 1 6 （√）
- C：3 4 6 5 2 1 （×）
- D：2 3 4 1 5 6 （√）

题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -> 5 -> 4 -> 3 -> 2 -> 1。

解析：

- A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;
- B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;
- C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；
- D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；
```

**栈常见的操作：**

- push（element）：添加一个新元素到栈顶位置；
- pop（）：移除栈顶的元素，同时返回被移除的元素；
- peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；
- isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；
- size（）：返回栈里的元素个数。这个方法和数组的length属性类似；
- toString（）：将栈结构的内容以字符串的形式返回。

### 2.1 封装栈

栈的实现：

- 基于数组
- 基于链表

**基于数组的栈代码实现：**

```javascript
class Stack {
  // 用数组来保存栈内元素
  constructor() {
    this.items = []
  }

  // 栈的相关操作：

  // 1.添加一个（或几个）新元素到栈顶
  push(element) {
    this.items.push(element)
  }

  // 2.移除栈顶的元素，同时返回被移除的元素
  pop() {
    return this.items.pop()
  }

  // 3.返回栈顶的元素，不对栈做任何修改
  peek() {
    return this.items[this.items.length-1]
  }

  // 4.判断栈是否为空，如果栈里没有任何元素就返回true，否则返回false
  isEmpty() {
    return this.items.length === 0
  }

  // 5.获取栈中元素个数
  size() {
    return this.items.length
  }

  // 6.移除栈里所有元素
  clear() {
    this.items = []
  }

  // 7.toString方法
  toString() {
    let resultString = ''
    for (const item of this.items) {
      resultString += item + ' '
    }
    return resultString
  }
}
```

**测试代码：**

```javascript
const stack = new Stack()

// push() 测试
stack.push(1);
stack.push(2);
stack.push(3);
console.log("输出栈",stack.items); //--> [1, 2, 3]

// pop() 测试
console.log("pop() 测试",stack.pop()); //--> 3

// peek() 测试
console.log("peek() 测试",stack.peek()); //--> 2

// isEmpty() 测试
console.log("isEmpty() 测试",stack.isEmpty()); //--> false

// size() 测试
console.log("size() 测试",stack.size()); //--> 2

// toString() 测试
console.log("toString() 测试",stack.toString()); //--> 1 2
```

**测试结果：**

<img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210071111684.png" alt="image-20221007111046106" style="zoom:50%;" />

### 2.2 栈简单应用

栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。

既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。利用栈结构的特点封装实现**十进制转换为二进制**的方法。

分析：

- 把十进制转换为二进制的通用方法就是模二取余法
- 将十进制数字不断模二取余，直到**被除数等于零**时停止
- 将得到的余数逆序输出即为相应二进制数字。

代码实现：

```js
function dec2bin(decNumber) {
  //1.定义一个栈对象，保存余数
  let stack = new StackArray()

  // 2.循环取余压栈
  while (decNumber > 0) {
    // 2.1.获取余数并放入栈中
    stack.push(decNumber % 2)
    // 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)
    decNumber = Math.floor(decNumber / 2)
  }

  // 3.按顺序出栈显示结果
  let binaryString = ''
  while (!stack.isEmpty()) {
    binaryString += stack.pop()
  }
  return binaryString
}
```

测试：

```js
// dec2bin() 测试
console.log(dec2bin(100)); //--> 1100100
console.log(dec2bin(88)); //--> 1011000
console.log(dec2bin(233)); //--> 11101001
```

## 三、队列（Queue）

队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)

**受限之处：**

- 只允许在表的前端（front）进行删除操作。
- 只允许在表的后端（rear）进行插入操作。

生活中类似队列结构的场景：

- 排队，比如在电影院，商场，甚至是厕所排队。
- 优先排队的人，优先处理。 (买票、结账、WC)。

<img src="https://could-img.oss-cn-hangzhou.aliyuncs.com/202210071404547.png" alt="image-20221007140031107" style="zoom:67%;" />

**队列的应用：**

- 打印队列：计算机打印多个文件的时候，需要排队打印；
- 线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理；

### 3.1 队列封装

队列的实现和栈一样，有多种方案：

- 基于数组实现。(效率低)
- 基于链表实现。

**队列常见的操作：**

- `enqueue(element)` 向队列尾部添加一个（或多个）新的项。
- `dequeue()` 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。
- `peek()` 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）。该方法在其他语言中也可以叫作front方法。
- `isEmpty()` 如果队列中不包含任何元素，返回 true，否则返回 false。
- `size()` 返回队列包含的元素个数，与数组的 length 属性类似。
- `toString()` 将队列中的内容，转成字符串形式。

```js
    // 基于数组封装队列类
    class Queue {
      constructor() {
    this.items = [];
       }
      
    // 方法
    // 1.enqueue():将元素加入到队列中
     enqueue = element => {
      this.items.push(element)
    }

    // 2.dequeue():从队列中删除前端元素
   dequeue = () => {
      return this.items.shift()
    }

    // 3.front():查看前端的元素
    front = () => {
      return this.items[0]
    }

    // 4.isEmpty:查看队列是否为空
   isEmpty = () => {
      return this.items.length == 0;
    }

    // 5.size():查看队列中元素的个数
  size = () => {
      return this.items.length
    }

    // 6.toString():将队列中元素以字符串形式输出
   toString = () => {
      let resultString = ''
        for (let i of this.items){
          resultString += i + ' '
        }
        return resultString
      }
    }
```

测试结果：

```js
// enqueue() 测试
queue.enqueue('a1212');
queue.enqueue('b');
queue.enqueue('c');
queue.enqueue('d');
console.log(queue.toString()); //--> a,b,c,d

// dequeue() 测试
queue.dequeue();
queue.dequeue();
console.log(queue.toString()); //--> c,d

// peek() 测试
console.log(queue.peek()); //--> c

// isEmpty() 测试
console.log(queue.isEmpty()); //--> false

// size() 测试
console.log(queue.size()); //--> 2

// toString() 测试
console.log(queue.toString()); //--> c d
```

### 3.2 队列应用

使用队列实现小游戏：

​	击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为数字num所指的元素时将该元素删除，直至数组剩下一个元素。

分析：

- 这里用队列比较好，先把所有参与的人按顺序加入到队列中，之后从头开始计数
- 没有数到相应数字的人从前端出队后再从后端入队
- 数到相应数字的人出队不再入队
- 不断重复这个流程直到只剩下一人，找出该人在原来队列中索引即可。

```js
// 队列应用：面试题：击鼓传花
let passGame = (nameList, num) => {
    //1.创建队列结构
    let queue = new Queue();

    //2.将所有人依次加入队列
    // 这是ES6的for循环写法，i相当于nameList[i]
    for (let i of nameList) {
        queue.enqueue(i);
    }

    // 3.开始数数
    while (queue.size() > 1) {
        //队列中只剩1个人就停止数数
        //不是num的时候，重新加入队列末尾
        //是num的时候，将其从队列中删除
        // 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)
        for (let i = 0; i < num - 1; i++) {
            queue.enqueue(queue.dequeue());
        }
        // 3.2.num对应这个人，直接从队列中删除
        /*
        思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，
        所以采用，把num前面的num-1个元素先删除后添加到队列末尾，
        这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除
      */
        queue.dequeue();
    }

    //4.获取剩下的那个人
    console.log("queue.size()", queue.size()); //1
    let endName = queue.peek();
    console.log("最终剩下的人：" + endName); ///Yilei

    return nameList.indexOf(endName);
};

//测试击鼓传花
let names = ["lily", "Nucy", "Tom", "Yilei", "Tony"];
passGame(names, 3); //Yilei
```

### 3.3 优先队列（PriorityQueue）

生活中类似**优先级队列**的场景：

- 优先排队的人，优先处理。 (买票、结账、WC)。
- 排队中，有紧急情况（特殊情况）的人可优先处理。

计算机中**优先级队列**的应用场景：

- 每个线程处理的任务重要性不同，我们可以通过优先级的大小，来决定该线程在队列中被处理的次序

优先级队列主要考虑的问题为：

- 每个元素不再只是一个数据，还包含数据的优先级；
- 在添加数据过程中，根据优先级放入到正确位置；

### 3.4 封装优先级队列

```js
// 优先队列内部的元素类
// 注意js是不能直接在class中声明class的，得单独声明两个类
class QueueElement {
    constructor(element, priority) {
        this.element = element;
        this.priority = priority;
    }
}

// 优先队列类（继承 Queue 类）
class PriorityQueue extends Queue {
    constructor() {
        console.log("77777777");
        super();
    }

    // enqueue(element, priority) 入队，将元素按优先级加入到队列中
    // 重写 enqueue()
    enqueue=(element, priority)=> {
        // 根据传入的元素，创建 QueueElement 对象
        const queueElement = new QueueElement(element, priority);

        // 判断队列是否为空
        if (this.isEmpty()) {
            // 如果为空，不用判断优先级，直接添加
            this.items.push(queueElement);
        } else {
            // 定义一个变量记录是否成功添加了新元素
            let added = false;

            for (let i = 0; i < this.items.length; i++) {
                // 让新插入的元素进行优先级比较，priority 值越小，优先级越大
                if (queueElement.priority < this.items[i].priority) {
                    // 在指定的位置插入元素
                    this.items.splice(i, 0, queueElement);
                    added = true;
                    break;
                }
            }

            // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后
            if (!added) {
                this.items.push(queueElement);
            }
        }
    }

    // 其余父类中的方法直接使用即可

    // toString() 将队列中元素以字符串形式返回
    // 重写 toString()
    toString=()=> {
        let result = "";
        for (let item of this.items) {
            result += item.element + "-" + item.priority + " ";
        }
        return result;
    }
}

//测试
const priorityQueue = new PriorityQueue();
// 入队 enqueue() 测试
priorityQueue.enqueue("A", 10);
priorityQueue.enqueue("B", 15);
priorityQueue.enqueue("C", 11);
priorityQueue.enqueue("D", 20);
priorityQueue.enqueue("E", 18);
console.log(priorityQueue.toString());
//--> output:
// A-10 C-11 B-15 E-18 D-20

// 出队 dequeue() 测试
priorityQueue.dequeue();
priorityQueue.dequeue();
console.log(priorityQueue.toString());
//--> output:
// B-15 E-18 D-20

// isEmpty() 测试
console.log(priorityQueue.isEmpty()); //--> false

// size() 测试
console.log(priorityQueue.size()); //--> 3

// toString() 测试
console.log(priorityQueue.toString()); //--> B-15 E-18 D-20
```

:::tip 

在父类使用箭头函数，子类使用传统函数时，子类实例会调用父类方法。

这是因为，在类中用`=`赋值就会挂载到实例上。

:::

```js
class Test {
   	t1 = 't1';
    t2 = () => {
        console.log('t2');
    }
    t3() {
        console.log('t3');
    }
}
console.log(Test.prototype);
console.log(new Test());     //t2会挂载在实例上 t3不会
```

![image-20221007205943589](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072059964.png)

## 四、链表（LinkedList）

链表和数组：

链表和数组一样，可以用于**存储一系列的元素**，但是链表和数组的**实现机制完全不同**。

- 数组：

  - 存储多个元素，数组（或列表）可能是**最常用**的数据结构。

  - 几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 `[]` 语法来访问数组元素。

- 数组缺点：
  - 数组的创建需要申请一段**连续的内存空间**(一整块内存)，并且大小是固定的，当前数组**不能满足容量需求**时，需要**扩容**。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)
  - 在数组开头或中间位置插入 / 删除数据的成本很高，需要进行大量元素的位移。

- 链表：

  - 存储多个元素，另外一个选择就是使用**链表**。

  - 不同于数组，链表中的元素在内存中**不必是连续的空间**。

  - 链表的每个元素由一个存储**元素本身的节点**和一个**指向下一个元素的引用**(有些语言称为指针)组成。

- 链表优点：
  - 内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的**内存动态管理**。
  - 链表不必在创建时就**确定大小**，并且大小可以**无限延伸**下去。
  - 链表在**插入和删除**数据时，**时间复杂度**可以达到 O(1)，相对数组效率高很多。
- 链表缺点：
  - 访问任何一个位置的元素时，需要**从头开始访问**。(无法跳过第一个元素访问任何一个元素)
  - 无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。
  - 虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。

- 如何选择

  - 频繁在中间或前面插入数据时选择链表

  - 需要使用下标去修改获取数据时选择数组

### 4.1 单向链表

单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。

- 链表的火车结构

  ![image-20221007210641478](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072106840.png)

- 链表的数据结构

  head 属性指向链表的第一个节点。
  链表中的最后一个节点指向 `null`。 当链表中一个节点也没有的时候，head 直接指向 `null`。

  ![image-20221007210707391](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072107544.png)

- 给火车加上数据后的结构

  ![image-20221007210728395](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072107500.png)

### 4.2 链表中的常见操作

常见操作可以按增删改查分类，剩下的几个都是获取链表信息的方法

- `append(element)` 向链表尾部添加一个新的项。
- `insert(position, element)` 向链表的特定位置插入一个新的项。
- `get(position)` 获取对应位置的元素。
- `indexOf(element)` 返回元素在链表中的索引。如果链表中没有该元素就返回-1。
- `update(position, element)` 修改某个位置的元素。
- `removeAt(position)` 从链表的特定位置移除一项。
- `remove(element)` 从链表中移除一项。
- `isEmpty()` 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。
- `size()` 返回链表包含的元素个数，与数组的 length 属性类似。
- `toString()` 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。

### 4.3 单向链表的封装

先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。

```js
// 封装链表节点类
class Node{
  constructor(data) {
    this.data = data
    this.next = null
  }
}

class LinkedList{
  constructor() {
    // 链表头节点，初始为 null
    this.head = null
    // 初始链表长度为 0
    this.length = 0
  }
}
```

##### append() 

 向链表尾部添加一个新的项。

过程图解：

- 首先让 `currentNode` 指向第一个节点。

  ![image-20221007211523278](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072115408.png)

- 通过 `while` 循环使 `currentNode` 指向最后一个节点，最后通过 `currentNode.next = newNode`，让最后一个节点指向新节点 `newNode`。

  ![image-20221007211548553](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072115232.png)

```js
// append(data) 往链表尾部追加数据
append(data) {

  // 1、创建新节点
  const newNode = new Node(data)

  // 2、追加新节点
  if (this.length === 0) {
    // 链表长度为 0 时，直接修改头指针head即可
    this.head = newNode
  } else {
    // 链表长度大于 0 时，在尾节点后面添加新节点
    // 先取得链表第一个节点，之后循环遍历至尾节点
    let currVE EAent = this.head
    // 当current.next!=null时表示不是尾节点
    while (current.next) {
      current = current.next
    }
    // 尾节点的 next 指向新节点
    current.next = newNode
  }

  // 3、追加完新节点后，链表长度 + 1
  this.length++
}
```

代码测试：

```js
const linkedList = new LinkedList();
// 测试 append 方法
linkedList.append('AA');
linkedList.append('BB');
linkedList.append('CC');
console.log(linkedList);
```

![image-20221007211628555](https://could-img.oss-cn-hangzhou.aliyuncs.com/202210072312575.png)

#####  toString()

```js
// toString() 链表数据以字符串形式返回
toString() {
  let current = this.head
  let resultString = 'a'

  // 遍历所有的节点，拼接为字符串，直到尾节点(值为null)
  while (current) {
    resultString += current.data + ' '//空格
    current = current.next
  }

  return resultString
}
```

测试代码：

```js
// 测试 toString 方法
console.log(linkedList.toString()); //--> AA BB CC
```

#####  insert()

向链表的特定位置插入一个新的项。

```js
// insert(position, data) 在指定位置（position）插入节点
insert(position, data) {
    // position 新插入节点的位置
    // position = 0 表示新插入后是第一个节点
    // position = 1 表示新插入后是第二个节点，以此类推

    // 1、对 position 进行越界判断，不能小于 0 或大于链表长度
    if (position < 0 || position > this.length) return false;

    // 2、创建新节点
    const newNode = new Node(data);

    // 3、插入节点
    if (position === 0) {
        // position = 0 即新插入节点为第一个节点的情况
        // 顺序很重要，先让新节点指向原来的第一个节点，之后修改头指针指向新节点

        // 让新节点的 next 指向 原来的第一个节点，即 head
        // newNode.next=原来第一个结点
        newNode.next = this.head;
        // head 赋值为 newNode
        //head指向新jiedian
        this.head = newNode;
    } else {
        // 0 < position <= length 的情况
        // 初始化一些状态变量
        let index = 0; // 遍历索引初始化为 0
        let current = this.head; // current指向head
        let previous = null; // 遍历的的上一节点初始化为 null

        // 在 0 ~ position 之间遍历，不断地更新 current 和 previous
        // 直到找到要插入的位置
        while (index++ < position) {
            previous = current;
            current = current.next;//指向下一个结点
        }

        // 在当前节点和当前节点的上一节点之间插入新节点，即改变它们的指向
        newNode.next = current;
        previous.next = newNode;
    }

    // 4、追加完新节点后，链表长度 + 1
    this.length++;
    // 5、返回新添加的节点，方便其他操作
    return newNode;
}
```

测试结果：

```js
// 测试 insert 方法
linkedList.insert(0, "123");
linkedList.insert(2, "456");
console.log(linkedList.toString()); //--> 123 AA 456 BB CC
```

##### getData()

获取指定位置（position）的 data。

```js
// getData(position) 获取指定位置的 data
getData(position) {
    // 1、position越界判断
    if (position < 0 || position >= this.length) return null;

    // 2、获取指定 position 的节点
    let index = 0;

    //position=2 从0开始算
    let current = this.head;//head不为空的话current=第一个结点
    //index= 0 current=
    //index= 1 current=  position=2
    //index=2 index不小于position
    while (index++ < position) {
        current = current.next;
    }

    // 3、返回相应节点的 data
    return current.data;
}
```

测试代码：

```js
// 测试 getData 方法
console.log(linkedList.toString()); //--> 123 AA 456 BB CC 
console.log(linkedList.getData(0)); //--> 123
console.log(linkedList.getData(1)); //--> AA
```

##### indexOf() 

indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。

```js
// indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。
indexOf(data) {
  // 1、定义遍历变量
  let index = 0
  let current = this.head

  // 2、遍历比较链表中数据
  while (current) {
    if (current.data === data) {
      // 找到相应数据,返回索引
      return index
    }
    current = current.next
    index++
  }

  // 未找到相应数据，返回-1
  return -1
}
```

代码测试：

```js
// 测试 indexOf 方法
console.log(linkedList.toString()); //--> 123 AA 456 BB CC 
console.log(linkedList.indexOf("AA")); //--> 1
console.log(linkedList.indexOf("ABC")); //--> -1
```

##### update() 

update(position, data) 修改指定位置节点的 data。

```js
// update(position, data) 修改指定位置节点的 data
update(position, data) {
  // 涉及到 position 都要进行越界判断
  // 1、position越界判断
  if (position < 0 || position >= this.length) return false

  // 2、循环遍历，找到指定 position 的节点
  let index = 0
  let current = this.head
  while (index++ < position) {
    current = current.next
  }

  // 3、修改相应节点的 data
  current.data = data
  // 4、返回指定 position 的节点，方便其他操作
  return current
}
#代码测试
```

 代码测试：

```js
// 测试 update 方法
linkedList.update(0, "12345");
console.log(linkedList.toString()); //--> 12345 AA 456 BB CC
linkedList.update(1, "54321");
console.log(linkedList.toString()); //--> 12345 54321 456 BB CC
```

##### removeAt() 

removeAt(position) 删除指定位置的节点。

```js
// removeAt(position) 删除指定位置的节点，并返回删除的那个节点
removeAt(position) {
  // 1、position越界判断
  if (position < 0 || position >= this.length) return null

  // 2、删除指定 position 节点
  let current = this.head
  if (position === 0) {
    // position = 0 的情况
    this.head = this.head.next
  } else {
    // position > 0 的情况
    // 在 0 ~ position 之间遍历，不断地更新 current 和 previous
    // 直到找到要删除的位置
    let index = 0
    let previous = null
    while (index++ < position) {
      previous = current
      current = current.next
    }
    // 让上一节点的 next 指向当前的节点的 next，相当于删除了当前节点。
    previous.next = current.next
  }

  // 3、更新链表长度 -1
  this.length--
  // 4、返回被删除的节点，方便其他操作
  return current
}
```

代码测试

```js
// 测试 removeAt 方法
linkedList.removeAt(3);
console.log(linkedList.toString()); //--> 12345 54321 456 CC
```

##### remove() 

remove(data) 删除指定 data 所在的节点。

代码实现：

```js
// remove(data) 删除指定 data 的节点，并返回删除的那个节点
remove(data) {
  return this.removeAt(this.indexOf(data))
}
```

代码测试：

```js
// 测试 remove 方法
linkedList.remove("CC");
console.log(linkedList.toString()); //--> 12345 54321 456
```

#### isEmpty() 

isEmpty() 判断链表是否为空。

代码实现：

```js
// isEmpty() 判断链表是否为空
isEmpty() {
  return this.length === 0
}
```

代码测试：

```js
// 测试 isEmpty 方法
console.log(linkedList.isEmpty()); //--> false
```

##### size() 

size() 获取链表的长度。

代码实现：

```js
// size() 获取链表的长度
size() {
  return this.length
}
```

代码测试：

```js
// 测试 size 方法
console.log(linkedList.size()); //--> 3
```

##### 完整实现

```js
// 封装链表节点类
export class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// 单向链表结构的封装
export class LinkedList {
    constructor() {
        // 链表头节点，初始为 null
        this.head = null;
        // 初始链表长度为 0
        this.length = 0;
    }

    // ------------ 链表的常见操作 ------------ //

    // append(data) 往链表尾部追加数据
    append(data) {
        // 1、创建新节点
        const newNode = new Node(data);

        // 2、追加新节点
        if (this.length === 0) {
            // 链表长度为 0 时，直接修改头指针head即可
            this.head = newNode;
        } else {
            // 链表长度大于 0 时，在尾节点后面添加新节点
            // 先取得链表第一个节点，之后循环遍历至尾节点
            let current = this.head;
            // 当current.next!=null时表示不是尾节点
            while (current.next) {
                current = current.next;
            }
            // 尾节点的 next 指向新节点
            current.next = newNode;
        }

        // 3、追加完新节点后，链表长度 + 1
        this.length++;
    }

    // insert(position, data) 在指定位置（position）插入节点
    insert(position, data) {
        // position 新插入节点的位置
        // position = 0 表示新插入后是第一个节点
        // position = 1 表示新插入后是第二个节点，以此类推

        // 1、对 position 进行越界判断，不能小于 0 或大于链表长度
        if (position < 0 || position > this.length) return false;

        // 2、创建新节点
        const newNode = new Node(data);

        // 3、插入节点
        if (position === 0) {
            // position = 0 即新插入节点为第一个节点的情况
            // 顺序很重要，先让新节点指向原来的第一个节点，之后修改头指针指向新节点

            // 让新节点的 next 指向 原来的第一个节点，即 head
            newNode.next = this.head;
            // head 赋值为 newNode
            this.head = newNode;
        } else {
            // 0 < position <= length 的情况

            // 初始化一些状态变量
            let index = 0; // 遍历索引初始化为 0
            let current = this.head; // 遍历的当前节点初始化为 head
            let previous = null; // 遍历的的上一节点初始化为 null

            // 在 0 ~ position 之间遍历，不断地更新 current 和 previous
            // 直到找到要插入的位置
            while (index++ < position) {
                previous = current;
                current = current.next;
            }

            // 在当前节点和当前节点的上一节点之间插入新节点，即改变它们的指向
            newNode.next = current;
            previous.next = newNode;
        }

        // 4、追加完新节点后，链表长度 + 1
        this.length++;
        // 5、返回新添加的节点，方便其他操作
        return newNode;
    }

    // getData(position) 获取指定位置的 data
    getData(position) {
        // 1、position越界判断
        if (position < 0 || position >= this.length) return null;

        // 2、获取指定 position 的节点
        let index = 0;
        let current = this.head;
        while (index++ < position) {
            current = current.next;
        }

        // 3、返回相应节点的 data
        return current.data;
    }

    // indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。
    indexOf(data) {
        // 1、定义遍历变量
        let index = 0;
        let current = this.head;

        // 2、遍历比较链表中数据
        while (current) {
            if (current.data === data) {
                // 找到相应数据,返回索引
                return index;
            }
            current = current.next;
            index++;
        }

        // 未找到相应数据，返回-1
        return -1;
    }

    // update(position, data) 修改指定位置节点的 data
    update(position, data) {
        // 涉及到 position 都要进行越界判断
        // 1、position越界判断
        if (position < 0 || position >= this.length) return false;

        // 2、循环遍历，找到指定 position 的节点
        let index = 0;
        let current = this.head;
        while (index++ < position) {
            current = current.next;
        }

        // 3、修改相应节点的 data
        current.data = data;
        // 4、返回指定 position 的节点，方便其他操作
        return current;
    }

    // removeAt(position) 删除指定位置的节点，并返回删除的那个节点
    removeAt(position) {
        // 1、position越界判断
        if (position < 0 || position >= this.length) return null;

        // 2、删除指定 position 节点
        let current = this.head;
        if (position === 0) {
            // position = 0 的情况
            this.head = this.head.next;
        } else {
            // position > 0 的情况
            // 在 0 ~ position 之间遍历，不断地更新 current 和 previous
            // 直到找到要删除的位置
            let index = 0;
            let previous = null;
            while (index++ < position) {
                previous = current;
                current = current.next;
            }
            // 让上一节点的 next 指向当前的节点的 next，相当于删除了当前节点。
            previous.next = current.next;
        }

        // 3、更新链表长度 -1
        this.length--;
        // 4、返回被删除的节点，方便其他操作
        return current;
    }

    // remove(data) 删除指定 data 的节点，并返回删除的那个节点
    remove(data) {
        return this.removeAt(this.indexOf(data));
    }

    // isEmpty() 判断链表是否为空
    isEmpty() {
        return this.length === 0;
    }

    // size() 获取链表的长度
    size() {
        return this.length;
    }

    // toString() 链表数据以字符串形式返回
    toString() {
        let current = this.head;
        let resultString = "";

        // 遍历所有的节点，拼接为字符串，直到尾节点(值为null)
        while (current) {
            resultString += current.data + " ";
            current = current.next;
        }

        return resultString;
    }
}
```

