---
title:  JS设计模式
date: 2021-09-01
categories: 
 - JavaScript
tags:
 - 设计模式
---

## 一、设计模式简介

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。

设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。

因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式：

- 比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件；

- 因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。

## 二、设计原则

**设计模式五大原则**

- 开放/封闭原则 `O – OpenClosed Principle `

    - 对扩展开放，对修改封闭  
    - 增加需求时，扩展新代码，而非修改已有代码

- 里氏替换原则 `L – Liskov Substitution Principle `

    - 继承必须确保超类所拥有的性质再子类中依旧成立
    - 子类可以扩展父类的功能，但不要修改父类原有的功能 
    -   尽量不要重写方法

- 依赖倒置原则 `D – Dependency Inversion Principle `

    - 面向接口编程，不面向实现编程。
    - 抽象不依赖细节，细节依赖抽象。 

- 单一职责原则 `S – Single Responsibility Principle `

    - 一个程序只做好一件事 。
    - 如果功能过于复杂就拆分开，每个部分保持独立
    - 控制类的粒度大小，将对象解耦，提高其内聚性

- 接口隔离原则 `I – Interface Segregation Principle`

    - 使用多个专门的接口，而不使用单一的总接口。
    - 为各个类建立它们需要的专用接口。
    - 类似单一职责原则，这里更关注接口。

## 三、设计模式分类

23种设计模式：

|<span style="display:inline-block;width:180px">创建型</span>  |   <span style="display:inline-block;width:200px">结构型 </span>  |   <span style="display:inline-block;width:200px">行为型 </span> |
| :----------: | :------------: | :------------: |
| 单例模式     |   适配器模式   | 观察者模式     |
|   原型模式   | 装饰器模式     |   迭代器模式   |
| 工厂模式     |    代理模式    |  策略模式  |
| 抽象工厂模式 |    外观模式    |  模板方法模式  |
|  建造者模式  |    桥接模式    |   职责链模式   |
|              |    组合模式    |    命令模式    |
|              |    享元模式    |   备忘录模式   |
|              |                |    状态模式    |
|              |                |   访问者模式   |
|              |                | 中介者模式|
|              |                |   解释器模式   |

### 3.1 创建型模式

创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。

### 3.2 结构型模式

创建型模式介绍创建对象的一些设计模式，构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。

### 3.3 行为型模式

行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。